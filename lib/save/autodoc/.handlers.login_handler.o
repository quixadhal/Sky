#/secure/handlers/autodoc/autodoc_file.c
public_functions (["query_login_queue":({({"object","*",}),({}),(["main":({"This method returns the current list of people in the loginqueue.",}),"return":({"the objects in the login queue",}),]),}),"query_lockdowns":({({"void",}),({}),(["main":({"This method prints all the locked down sites.",}),]),}),"remove_from_login_queue":({({"void",}),({({"object",}),"ob",}),(["main":({"This method removes an object from the login queue, if they log outor something.",}),"param":({"ob the object to remove from the queue",}),]),}),"query_players_on":({({"string","*",}),({}),(["main":({"This method returns a list of the current players who areonline.",}),"return":({"the string names of the online players",}),]),}),"add_dynamic_login_call":({({"int",}),({({"string",}),"player",({"mixed",}),"funct",({"mixed",}),"obj",}),(["main":({"This method adds a funct to be called whenever a player logsin.  The funct and object are stored only for this rebootso they may be object references or funct pointers.",}),"see":({"remove_dynamic_login_call()","add_static_login_call()",}),"param":({"player specfic player to look for \"all\" for everyone","func the funct to call","obj the object to call the funct on",}),"return":({"0 on failure and 1 on success",}),]),}),"remove_static_login_call":({({"int",}),({({"string",}),"player",({"mixed",}),"funct",({"mixed",}),"obj",}),(["main":({"This method removes a login call.",}),"see":({"add_static_login_call()","add_dynamic_login_call()",}),"param":({"player the player specifier","funct the funct name","obj the object to call the funct on",}),"return":({"0 on failure and 1 on success",}),]),}),"query_worst":({({"string",}),({}),(["main":({"This returns the player name with the worst alignment.",}),"return":({"player name with the worst alignment",}),]),}),"pop_from_login_queue":({({"object",}),({}),(["main":({"This method returns the top element of the login queue and removesthem from it.",}),"return":({"the top element of the login queue, 0 if none",}),]),}),"remove_dynamic_login_call":({({"int",}),({({"string",}),"player",({"mixed",}),"funct",({"mixed",}),"obj",}),(["main":({"This method removes a login call.",}),"see":({"add_dynamic_login_call()","add_static_login_call()",}),"param":({"player the player specifier","funct the funct name","obj the object to call the funct on",}),"return":({"0 on failure and 1 on success",}),]),}),"get_message":({({"string",}),({({"string",}),"mess_name",}),(["main":({"This function is used to cache the login messages used by /secure/loginit costs a bit in memory but saves us having to re-read the same textfile everytime someone logs in.For security reasons this function will only work with files in /doc",}),"param":({"the filename of the file to be returned",}),"return":({"the text of the file.",}),]),}),"get_login_mode":({({"string",}),({({"int",}),"lvl",}),(["main":({"This method returns a description for the specified restrictionlevel in a string.",}),"param":({"lvl the restriction level to return a description for",}),"return":({"a string describing the restriction level",}),]),}),"query_can_log_in":({({"int",}),({({"string",}),"who",}),(["main":({"This method tests to see whether a specific person canlog on at the time.",}),"param":({"who the name of the person trying to log in",}),"return":({"1 if they are allowed to log in, 0 if not",}),]),}),"query_login_mode":({({"int",}),({}),(["main":({"This method returns our login restriction level.The return value is one of the following.0 - unrestricted1 - restricted to playtesters2 - restricted to creators",}),"see":({"set_login_mode()",}),"return":({"0, 1 or 2",}),]),}),"is_discworld_full":({({"int",}),({({"int",}),"logins",}),(["main":({"Try and figure out if the mud is full or not.  Counts the numberof players and returns a true or false value.",}),"param":({"logins a flag",}),"see":({"/include/login.h#WITHOUT_LOGINS_NOT_IN_QUEUE","/include/login.h#WITHOUT_LOGIN_QUEUE","/include/login.h#WITHOUT_ANY_LOGINS",}),"return":({"1 if the mud is full, 0 if it is not",}),]),}),"set_login_mode":({({"int",}),({({"int",}),"lvl",}),(["main":({"This method sets the restriction level for loggin in.This can be used to restrict access to the mud at three levels.0 - unrestricted1 - restricted to playtesters2 - restricted to creators",}),"see":({"query_login_mode()",}),"param":({"lvl the restriction level",}),"return":({"1 upon success, 0 upon failure",}),]),}),"add_static_login_call":({({"int",}),({({"string",}),"player",({"mixed",}),"funct",({"mixed",}),"obj",}),(["main":({"This method adds a funct to be called whenever a player logsin.  The funct and object both need to be strings so thatthey are saved correctly.  This will be saved to the save fileand restored over logins.<p>The function will be called with two parameters, the first is thename of the player and the second is the type of the event.  Theevent types are defined in /include/login.h  The event will be oneof RECONNECT, LOGIN, LOGOUT, NETDEATH.",}),"see":({"remove_static_login_call()","add_dynamic_login_call()",}),"param":({"player specfic player to look for \"all\" for everyone","func the funct to call","obj the object to call the funct on",}),"return":({"0 on failure and 1 on success",}),]),}),"add_to_login_queue":({({"void",}),({({"object",}),"login_ob",}),(["main":({"This method adds an object to the login queue.  This is called frominside /secure/login.c",}),"param":({"login_ob the object to add to the queue",}),"see":({"/secure/login.c",}),]),}),"query_best":({({"string",}),({}),(["main":({"This returns the player name with the best alignment.",}),"return":({"player name with the best alignment",}),]),}),])
protected_functions ([])
inherits ([])
main_docs (["changed":({"Added the possibility to restrict login access - Sandoz, 2003.",}),"main":({"The login handler lets you have a funct called as a player logs in or out.The funct you setup will be called when the player logs in or out.  Theobject will also give you a list of all the people who are logged in. This isa by product of its method of operation rather than anything important.It is quite possibly more useful to call users().<p>The funct which is to be called only needs to be called once asthe objects state is saved.  When a player enters, logsout or goesnet dead the funct will be called on the specified object.  Thefunct will have two parameters, the first will be the playername logging in/out and the last will be a define from /include/login.hspecifying which sort of event has occured.<p>A new temporary method of adding a call back to the login_handler has beenadded.  This will allow you to add a call that is not saved,so you can use an object reference instead of a file name.",}),"author":({"Furball",}),"see":({"/secure/login","efun::users()","/include/login.h",}),])
define_docs (["LOCKDOWN_TIME":([]),"LOG_FILE":([]),"SAVE_NAME":([]),"SAVE_TIME":([]),"MAX_FAILURES":([]),])
includes (["/secure/include/login.h":962429079,"/include/player_handler.h":962428284,"/secure/include/colors.h":971575658,"/secure/include/login_handler.h":962429079,])
class_docs (["login_information":({0,({({"ob",({"mixed",}),}),({"funct",({"string",}),}),}),([]),}),])
file_name "/handlers/login_handler.c"
last_changed 1056658598
