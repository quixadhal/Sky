#/secure/handlers/autodoc/autodoc_file.c
public_functions (["query_expression_string":({({"string",}),({({"class","parse_node","*",}),"expr",({"int",}),"brief",}),(["main":({"This method returns the expresion as a string.",}),"param":({"expr the expression","brief don't expand the variable names",}),"return":({"the expression as a string",}),]),}),"evaluate_expression":({({"class","parse_node",}),({({"class","parse_node","*",}),"expr",({"mixed","args",}),"...",}),(["main":({"This method evaluates the expression and creates a nice end resultthingy.",}),"param":({"expr the exrpession to evaluate","args the optional args parsed into the various function calls",}),"return":({"the type and value of the expression, 0 if failed",}),]),}),"parse_integer_string":({({"class","parse_node","*",}),({({"string",}),"str",}),(["main":({"A very small recursive decent parser which must return a integervalue.",}),"param":({"str the input string",}),"return":({"the array control structure",}),]),}),"query_null_type":({({"class","parse_node",}),({({"int",}),"type",}),(["main":({"This method returns a null object of the specified type.",}),"param":({"type the type to get the null object of",}),"return":({"the null object",}),]),}),"query_operator_name":({({"string",}),({({"int",}),"operator",}),(["main":({"This method returns the string value of the operator name.",}),"param":({"operator the operator name to return",}),"return":({"the string name of the operator",}),]),}),"add_allowed_function":({({"void",}),({({"string",}),"name",({"int",}),"type",({"int","*",}),"args",({"function",}),"value",}),(["main":({"This method adds in an allowe function and specifies the types ittakes.",}),"param":({"name the name of the function","type the return type of the function","args the types of the arguements (an array)","value the function to call to get the value",}),]),}),"add_allowed_variable":({({"void",}),({({"string",}),"name",({"int",}),"type",({"function",}),"value",}),(["main":({"This method adds in an allowed variable and specifies it's type.",}),"param":({"name the name of the variable","type the type of the variable","value the value of the variable",}),]),}),"query_last_expression_error":({({"string",}),({}),(["main":({"This method returns the last error if there was an error in the parsing.",}),"return":({"the last error",}),]),}),"query_type_name":({({"string",}),({({"int",}),"type",}),(["main":({"This method returns the name of the type.",}),"param":({"type the type to get the string name of",}),"return":({"the string name of the type",}),]),}),"query_function_value":({({"function",}),({({"string",}),"name",}),(["main":({"This method returns the value of the function.",}),"param":({"name the name of the function to find",}),"return":({"the value of the function, 0 if not found",}),]),}),"query_variable_value":({({"function",}),({({"string",}),"name",}),(["main":({"This method returns the value of the variable.",}),"param":({"name the name of the variable to find",}),"return":({"the value of the variable, 0 if not found",}),]),}),"parse_money_string":({({"class","parse_node","*",}),({({"string",}),"str",}),(["main":({"A very small recursive decent parser which must return a moneyvalue.",}),"param":({"str the input string",}),"return":({"the array control structure",}),]),}),"parse_boolean_string":({({"class","parse_node","*",}),({({"string",}),"str",}),(["main":({"A very small recursive decent parser which must return a booleanvalue.",}),"param":({"str the input string",}),"return":({"the array control structure",}),]),}),"query_function_type":({({"int",}),({({"string",}),"name",}),(["main":({"This method returns the type of the function.",}),"param":({"name the name of the function to check",}),"return":({"the type of the function, EXPRESSION_TYPE_ERROR if there is nofunction",}),]),}),"query_variable_type":({({"int",}),({({"string",}),"name",}),(["main":({"This method returns the type of the variable.",}),"param":({"name the name of the variable to check",}),"return":({"the type of the variable, EXPRESSION_TYPE_ERROR if there is novariable",}),]),}),])
protected_functions (["query_token":({({"string","*",}),({({"string",}),"str",}),(["main":({"This method find the next token.  It can be overrideen in higher thingsto deal with special token types (ie: money).",}),"param":({"str the input string",}),"return":({"({ token, rest })",}),]),}),"is_space":({({"int",}),({({"int",}),"space",}),(["main":({"This method checks to see if the passed in character is a space ora space equivilant.",}),"param":({"space the character to check",}),"return":({"1 if it is a space, 0 if not",}),]),}),"is_number_type":({({"int",}),({({"int",}),"type",}),(["main":({"This checks to make sure that the type is a number based type.This can be controlled to make sure that any added types are alsoallowed to be treated as numbers.",}),"param":({"type the type to check",}),"return":({"1 if it is a number, 0 if not",}),]),}),"is_alpha":({({"int",}),({({"int",}),"alpha",}),(["main":({"This method checks to see if the passed in character is an alphaor not.",}),"param":({"alpha the character to check",}),"return":({"1 if it alpha, 0 if not",}),]),}),"is_number":({({"int",}),({({"int",}),"number",}),(["main":({"This method checks to see if the passed in character is a numberor not.",}),"param":({"number the character to check",}),"return":({"1 if it is a number, 0 if not",}),]),}),])
inherits ([])
main_docs (["main":({"This is an inheritable to handle certain sorts of expressions in stuff.These expression can be setup by players (or creators) and then runor evaluated.  It allows controlling the types usable by the expressionhandlers, strings, arrays, mappings, integers and floats.",}),"started":({"Thu May  4 22:44:34 PDT 2000",}),"author":({"Pinkfish",}),])
define_docs (["EXPRESSION_GREATOR_THAN":([]),"EXPRESSION_PLUS":([]),"EXPRESSION_MINUS":([]),"EXPRESSION_AND":([]),"EXPRESSION_OR":([]),"EXPRESSION_FUNC_NO_ARGS":([]),"EXPRESSION_TRUE":([]),"EXPRESSION_NOT":([]),"EXPRESSION_MULTIPLY":([]),"EXPRESSION_FALSE":([]),"EXPRESSION_DIVIDE":([]),"EXPRESSION_IF":([]),"EXPRESSION_GREATOR_OR_EQUAL":([]),"EXPRESSION_TYPE":([]),"EXPRESSION_NOT_EQUAL_TO":([]),"EXPRESSION_EQUAL_TO":([]),"EXPRESSION_PARSE_STRING":([]),"EXPRESSION_FUNC_NAME":([]),"EXPRESSION_TREE":([]),"EXPRESSION_LESS_OR_EQUAL":([]),"EXPRESSION_LESS_THAN":([]),])
includes (["/include/expressions.h":962428284,"/include/money.h":1049974076,])
class_docs (["function_thing":({0,({({"type",({"int",}),}),({"value",({"function",}),}),({"arg_types",({"int","*",}),}),}),([]),}),"variable_thing":({0,({({"type",({"int",}),}),({"value",({"function",}),}),}),([]),}),])
file_name "/std/basic/expressions.c"
last_changed 1000719737
