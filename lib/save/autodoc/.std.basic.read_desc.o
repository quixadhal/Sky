#/secure/handlers/autodoc/autodoc_file.c
public_functions (["set_max_size":({({"void",}),({({"int",}),"siz",}),(["main":({"This method sets the maximum amount of writing that can beplaced onto the object.",}),"see":({"query_max_size()","add_read_mess()",}),"param":({"siz the maximum size",}),]),}),"query_read_short":({({"string",}),({({"object",}),"player",({"int",}),"dummy",}),(["main":({"This method returns the short description to use with the reading.It will go: You read <read short>:<p>It will automaticly add a $name$ onto the end of the string for you.This will be replaced with the correct a/the short for the messagewhich is printed.",}),"param":({"player the player reading the message",}),]),}),"add_read_mess":({({"varargs","string",}),({({"string",}),"str",({"string",}),"type",({"string",}),"lang",({"int",}),"size",}),(["main":({"This method adds a new read message onto the object.<p>The str bit is the actual string to add, it is the message whichwill get printed. The type is the type of the writing, like \"spiderywriting\" or \"charcoal based letters\".  The language is thelanguage in which it is written and the size is the size of theletters (standard handwriting should be of size 1).The size is used to see if the writing can fit on the page.<p>If no language is given, the default is \"common\".  If no type isgiven, then no type bit is printed and if no size is specified thena size of 1 is the default.<p>This also adjusts the size of stuff on the object.  If too muchis attempted to be written on the object, the remainder will becut off.",}),"see":({"query_read_mess()","set_max_size()","/handlers/language->query_language_size()","/handlers/language->squidge_text()",}),"param":({"str the text of the message","type the type of the message","lang the language the message is in","size the size of the message",}),"return":({"the text that was successfully written onto the object",}),]),}),"test_add_read_mess":({({"int",}),({({"string",}),"str",({"string",}),"type",({"string",}),"lang",({"int",}),"size",}),(["main":({"This method queries whether or not the specified textfits on this object.  The arguments to this function areidentical to those of add_read_mess().",}),"return":({"1 if the text fits on the object, 0 if not",}),]),}),"set_read_mess":({({"varargs","void",}),({({"mixed",}),"str",({"string",}),"lang",({"int",}),"size",}),(["main":({"Calling this is very rude unless you are creating the object as iterases all of the writing off it!",}),]),}),"query_readable_message":({({"string",}),({({"object",}),"player",({"int",}),"dummy",}),(["main":({"This method returns the read message for the object.  This is what shouldbe displayed to the player if they attempt to read this object.",}),"return":({"the read message, 0 if there is none",}),]),}),"query_cur_size":({({"int",}),({}),(["main":({"This method returns the size of the current amount of writingon the object.",}),"see":({"set_max_size()","add_read_mess()","set_cur_size()",}),"return":({"the current amount of writing on the object",}),]),}),"remove_read_mess":({({"int",}),({({"string",}),"str",({"string",}),"type",({"string",}),"lang",}),(["main":({"This method removes a piece of writing off the object.<p>If you know the actual message or the language or the type you can removethat message.<p>Using the type and or language is a very dodgy way of doing this.  Usinga combination is much better.<p>Any of the parameters set to a non-zero value will be used for the search.",}),"see":({"/handlers/language->query_language_size()","add_read_mess()","query_read_mess()",}),"param":({"str the text string","type the type of the text","lang the language it is written in",}),"return":({"0 if the text was not found, 1 if it was",}),]),}),"query_read_mess":({({"mixed",}),({}),(["main":({"This method returns the current read messae array on the object.The returned array consists of an array of arrays.  The internalarray has 4 elements, the first is the text of the messagethe second is the type of the message, the third is the languageand the last element is the size of the writing.<p>The defines in the file /include/language.h should be usedfor the indexes into this array.",}),"see":({"add_read_mess()","set_max_size()","/include/language.h",}),"return":({"the read message array",}),]),}),"add_detail":({({"void",}),({({"mixed",}),"d_name",({"string",}),"mess",}),(["main":({"This method adds details for an item.",}),"param":({"d_name the name(s) of the detail","mess the descripton of the item",}),]),}),"set_cur_size":({({"void",}),({({"int",}),"siz",}),(["main":({"This method sets the size of the current amount of writingon the object.",}),"param":({"siz the new current size",}),"see":({"set_max_size()","add_read_mess()","query_cur_size()",}),]),}),"query_max_size":({({"int",}),({}),(["main":({"This method returns the current maximum text size of the object.",}),"see":({"set_max_size()","add_read_mess()",}),"return":({"the current maximum text size",}),]),}),"query_detail":({({"string",}),({({"string",}),"str",}),(["main":({"This method returns the current value of the detail for an item.",}),"param":({"str the detail to get",}),"return":({"the detail for an item",}),]),}),])
protected_functions ([])
inherits (["/std/basic/desc":({}),])
main_docs (["main":({"This method keeps track of all the messages on the object forreading etc.  Keeps track of the language, the text and thesize.",}),"author":({"Pinkfish",}),])
define_docs ([])
includes (["/include/language.h":980398293,])
class_docs ([])
file_name "/std/basic/read_desc.c"
last_changed 1200761934
