#/secure/handlers/autodoc/autodoc_file.c
public_functions (["match_objects_in_environments":({({"class","obj_match",}),({({"string",}),"input",({"mixed",}),"env_list",({"int",}),"singular",({"object",}),"player",}),(["main":({"Find an object in the given environments that match the given words.This will only return a correct match if the entire stringmatches.  If it gets a partial match then nothing will bereturned.  The return array is of the format:<br><pre>({ flag, class obj_match info })</pre>The flag can be one of:<dd><dt>OBJ_PARSER_SUCCESS<dd>Successfuly matched the objects.  the objects part of the class willcontain the matched objects.<dt>OBJ_PARSER_NO_MATCH<dd>No successful match.  The text bit of the omatch class will containthe text that didn't match<dt>OBJ_PARSER_AMBIGUOUS<dd>An ambigous match is returned, this means 'frog' was referencedwhen there was more than one frog.  The objects part of the classhas all the objects there were matched<dt>OBJ_PARSER_BAD_FRACTION<dd>The specified fracition was bad, the text bit of the class containsthe bad fraction.<dt>OBJ_PARSER_FRACTION<dd>Means that a fraction was attempted to be applied to multipleobjects.<dt>OBJ_PARSER_TOO_DARK<dd>Unable to match the specified object because it is too dark.</dl>",}),"param":({"input the input string to match","env_list the environments to get the objects from","singular force a singular match","player the person doing the lookup",}),"return":({"an array of the format ({ flag, class obj_match info })",}),]),}),"filter_in_me_or_environment":({({"object","*",}),({({"object","*",}),"obs",({"object",}),"player",}),(["main":({"This method returns the array of objects that are only inside theplayer in question, or in their environment.  It excludes any itemsin other peoples inventorys.",}),"param":({"obs the objects to filer","player the player to check",}),"return":({"the filtered objects",}),]),}),"match_objects_for_existence":({({"object","*",}),({({"string",}),"input",({"object","*",}),"env_list",({"object",}),"player",}),(["main":({"This method checks for existance of the specified objects.  It willreturn any ambiguous matches as well as real matches.  This should onlybe used in cases in the code where it is not nessessary to distinguishbetween different objects of the same type.",}),"param":({"input the input string to check","env_list the environments to check in","player the player to check with",}),"return":({"the array of objects",}),]),}),"match_object_in_array":({({"class","obj_match",}),({({"string",}),"input",({"object","*",}),"ob_list",({"int",}),"singular",({"object",}),"player",}),(["main":({"Find an object in the given array that matches the given words.This will only return a correct match if the entire stringmatches.  If it gets a partial match then nothing will bereturned.  The return array is of the format:<br><pre>({ flag, class obj_match info })</pre>The flag can be one of:<dd><dt>OBJ_PARSER_SUCCESS<dd>Successfuly matched the objects.  the objects part of the class willcontain the matched objects.<dt>OBJ_PARSER_NO_MATCH<dd>No successful match.  The text bit of the omatch class will containthe text that didn't match<dt>OBJ_PARSER_AMBIGUOUS<dd>An ambigous match is returned, this means 'frog' was referencedwhen there was more than one frog.  The objects part of the classhas all the objects there were matched<dt>OBJ_PARSER_BAD_FRACTION<dd>The specified fracition was bad, the text bit of the class containsthe bad fraction.<dt>OBJ_PARSER_FRACTION<dd>Means that a fraction was attempted to be applied to multipleobjects.<dt>OBJ_PARSER_TOO_DARK<dd>Unable to match the specified object because it is too dark.</dl>",}),"param":({"input the input string to match","ob_list the object to list to match in","singular force a singular match","player the person doing the lookup",}),"return":({"an array of the format ({ flag, class obj_match info })",}),]),}),"is_in_me_or_environment":({({"int",}),({({"object",}),"ob",({"object",}),"player",}),(["main":({"This method checks to see if the specified object is in the playeror the environment.  If it has no environment it is considered tobe here.",}),"param":({"ob the object to test","player the player to check against",}),"return":({"1 if it is, 0 if not",}),]),}),"match_objects_failed_mess":({({"string",}),({({"class","obj_match",}),"failed_match",}),(["main":({"This method returns the failed message for the specifiedfailed match string.",}),"param":({"failed_match the return result from match_objects_*",}),"return":({"the message to print when it gets an error",}),]),}),"query_multiple_short":({({"varargs","string",}),({({"mixed",}),"args",({"string",}),"type",({"int",}),"no_dollars",({"int",}),"flag",}),(["main":({"Returns a nice string which looks like \"Frog, fish and chicken\".  Thistakes in an array of objects and or strings and returns a messagelike that shown above.  It also does things like adding the number ofeach type at the start of the function.<p>This function has two main uses: to produce the control codes for a    set of objects and to produce a nice list from a set of strings.    The \"type\" argument is optional and may be \"a\", \"the\", \"one\" or    \"poss\", defaulting to \"a\": it determines which of a_short,    the_short, one_short or poss_short will be used to make the control    code sequence for the objects in \"args\".  If all of the elements of    \"args\" are objects, it simply returns the block control code for    the relevant shorts of the objects.  Otherwise, it looks through    the elements one at a time, replacing objects by the result of    calling the relevant short function on them; finally it    concatenates the elements with commas between each pair, except    between the last pair which have \" and \" between them.  Since the    output will contain processing codes if there are any objects in    \"args\", it should be passed through convert_message before being    stored.",}),"param":({"args the array to do the processing on","type the type of short to use \"a\", \"the\", \"one\", \"poss\"","no_dollars this forces the output to be a real string",}),"return":({"the processed string",}),]),}),])
protected_functions ([])
inherits ([])
main_docs (["changes":({"2000-04-20   Scatter    File created.","2000-05-20   Pinkfish   Adapted to Discworld",}),"main":({"This is the object matching code.It is based on some code by Scatter at Dawn Whispers, although this isboth cut down and extended from what scatter had written.",}),])
define_docs (["TRACE(ARG)":([]),])
includes (["/include/obj_parser.h":1049992949,])
class_docs ([])
file_name "/secure/simul_efun/obj_parser.c"
last_changed 1049992971
