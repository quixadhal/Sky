#/secure/handlers/autodoc/autodoc_file.c
public_functions (["query_succ_mess_indir":({({"object","*",}),({}),(["main":({"This method returns all the indirect objects used in the successmessages.",}),"return":({"the success message",}),]),}),"query_p_commands":({({"mapping",}),({}),(["main":({"This method returns the current internal set of commands.<p>([ \"command_name\" :<br>({ ({ pattern_weight, pattern_str, nn, object, function }) })<br>])",}),"see":({"query_p_objects()",}),"return":({"the current commands list",}),]),}),"new_parser":({({"nomask","int",}),({({"string",}),"str",}),(["main":({"This method does all the real work for add_command parsing.",}),]),}),"add_failed_mess":({({"int",}),({({"object",}),"dir",({"string",}),"mess",({"object","*",}),"in_dir",}),([]),}),"syntax_messages":({({"int",}),({({"string",}),"str",}),([]),}),"query_succ_mess_dir":({({"object","*",}),({}),(["main":({"This method returns the objects which have success messages alreadyattached for.  This allows you to determine which objects already hacea success message available.  This array is added to by both theadd_succeeded_mess and add_failed_mess methods, it disable theautogeneration of these messages.",}),"see":({"add_succeeded_mess()","add_failed_mess()",}),"return":({"the succeeded message objects",}),]),}),"check_if_allowed":({({"int",}),({({"object",}),"ob",}),([]),}),"handle_command":({({"int",}),({({"string","*",}),"bits",({"int","*",}),"matches",({"mixed",}),"pattern",({"mixed",}),"command",}),([]),}),"add_succeeded_mess":({({"int",}),({({"object",}),"dir",({"mixed",}),"incoming_mess",({"object","*",}),"in_dir",}),([]),}),"add_command":({({"varargs","int",}),({({"string",}),"command",({"object",}),"ob",({"mixed",}),"format",({"function",}),"funct",}),([]),}),"remove_object2":({({"varargs","int",}),({({"mixed",}),"ob",({"int",}),"flag",}),(["main":({"This method does all the horrible work of removing objectsand being evil.The bit that does all the horrible work...We check in here to make sure we havent come back to the same spot.This is so we don't go round deleteing things we shouldn't.",}),]),}),"check_if_creator":({({"int",}),({({"object",}),"ob",}),([]),}),"query_p_objects":({({"mapping",}),({}),(["main":({"This method returns the current mapping between objects and commands.<br>([ object : ({ \"cmd1\", \"cmd2\", ... }), ... ])<p>This mapping is used when the object leaves the environment to makethe command updating more efficent.",}),"see":({"query_p_commands()",}),"return":({"the current object/command mapping",}),]),}),"setup_failed_mess":({({"void",}),({({"class","obj_match",}),"failed_match",}),([]),}),"add_succeeded":({({"int",}),({({"mixed",}),"ob",}),(["main":({"This is called by the object the command is being passed on to findwhether or not it succeeded on the objects it was passed... and whichones. This can be passed an object.. or an array of objects.Share and enjoy.",}),]),}),"get_fail_messages":({({"string",}),({({"string",}),"verb",({"object","*",}),"fail_obs",}),([]),}),"print_special_messages":({({"void",}),({({"string",}),"verb",}),([]),}),"check_living":({({"int",}),({({"object",}),"ob",}),([]),}),"pattern_match":({({"int","*",}),({({"string","*",}),"bits",({"mixed",}),"pattern",}),([]),}),"query_parse_command":({({"mixed",}),({({"string",}),"name",}),(["main":({"This method returns the information associated with the specificcommand.",}),"param":({"name the command name to return info on",}),"return":({"the information associated with the command",}),]),}),"query_failed_message_exists":({({"int",}),({({"object",}),"dir",}),(["main":({"This method checks to see if the given object has already added a failedmessage yet or not.  This is checking for a direct object, not anindirect object.",}),"see":({"add_failed_mess()",}),"param":({"dir the object adding the failed message",}),"return":({"0 if not found, 1 if found",}),]),}),"create_message":({({"varargs","string",}),({({"string","*",}),"bits",({"int","*",}),"matches",({"mixed",}),"pattern",({"object","*",}),"dir",({"int",}),"flag",}),([]),}),"remove_object":({({"int",}),({({"mixed",}),"ob",({"int",}),"was_env",}),([]),}),])
protected_functions ([])
inherits (["/global/player/command":({}),])
main_docs (["main":({"This file contains all the code to support and run the text parsingsystem used by discworld.  This is called 'add_command', please seehelp on add_command for a more detailed listing.",}),"author":({"Pinkfish",}),])
define_docs (["MY_MESS_HEADER":([]),"OTHER_MESS_HEADER":([]),])
includes (["/include/obj_parser.h":1049992949,"/include/command.h":1010295178,"/include/user_parser.h":962428284,"/include/soul.h":962698560,"/include/creator.h":999081333,])
class_docs (["fail_mess_data":({0,({({"direct",({"object","*",}),}),({"indirect",({"object","*",}),}),({"weight",({"int",}),}),}),([]),}),])
file_name "/global/player/new_parse.c"
last_changed 1200761933
