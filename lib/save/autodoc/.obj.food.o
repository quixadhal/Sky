#/secure/handlers/autodoc/autodoc_file.c
public_functions (["set_liquid":({({"void",}),({}),(["main":({"This changes the food object into a liquid.  Liquids areautomatically a 'continuous' medium, which means it willcombine with other liquids of the same type.<p>This will automatically set the decay speed to 0.  Liquidsdo not decay.",}),"see":({"reset_liquid()","set_decay_speed()","/obj/cont_medium->set_continuous()",}),]),}),"do_cut":({({"varargs","int",}),({({"int",}),"num_pieces",}),(["main":({"This cuts the food up into bits.  This is the command calledwith add_command() and does the actual cutting up into bits.  Ifthe num_pieces parameter is undefined, the food is cut in half.If the food is continuous, the cutting is handled bythe state_change handler (all continuous objects must be cut thisway).",}),"param":({"num_pieces the number of pieces to cut the food into",}),"see":({"set_piece_description()","query_in_pieces()","query_piece_short()","query_piece_plural()","query_piece_substance()",}),"return":({"1 if it succeeded, 0 if not.",}),]),}),"consume":({({"varargs","void",}),({({"object",}),"consumer",({"int",}),"amount",({"string",}),"type",}),(["main":({"This consumes some of the food.",}),"param":({"consumer The person doing the consumption.","amount The amount being consumed.","type Use \"splash\" or \"apply\" or \"external\" to use externaleffects, anything else for eat effects.",}),]),}),"query_eat_mess":({({"string",}),({}),(["main":({"This returns the eat message of the object.",}),"see":({"set_eat_object()","set_eat_func()","set_eat_mess()",}),"return":({"the eat message",}),]),}),"query_decay_speed":({({"int",}),({}),(["main":({"This returns the decay speed.  If this is 0 then the objectis not decaying.  This is the length of time it takesfor the whole object to decay.",}),"see":({"set_decay_speed()",}),"return":({"the decay speed",}),]),}),"do_mince":({({"varargs","int",}),({}),([]),}),"query_eat_func":({({"string",}),({}),(["main":({"This returns the name of the eat function to carry outwhen the object is eaten.",}),"see":({"set_eat_object()","set_eat_func()","set_eat_mess()",}),"return":({"the name of the eat function",}),]),}),"do_splash":({({"int",}),({({"object","*",}),"things",}),([]),}),"unset_splashable":({({"void",}),({}),(["main":({"This sets it so the food cannot be splashed.Note that the food can only be splashed when liquid in any case.",}),"see":({"set_splashable()",}),]),}),"setup_eat_piece_messages":({({"void",}),({({"string",}),"piece",({"string",}),"amt",({"string",}),"last",}),(["main":({"This sets up the eat messages for pieces and stuff.  The amount messagewill replace the $amt$ string in the message with the amount_string().",}),"param":({"piece the eat piece message","amt the amount messages","last the message to print out when the last bit gets eaten",}),]),}),"set_decay_speed":({({"void",}),({({"int",}),"decay",}),(["main":({"This sets the speed at which a food object decays.  Thespeed is set in seconds and is the total amount of timebefore the food decays.<p>If the decay speed is set to 0, then the object will never decay.",}),"see":({"set_decay_level()","query_decay_speed()",}),"param":({"speed The speed at which the object will decays.",}),"example":({"/* This will make the object decay totaly in 30 minutes */set_decay_speed(1800);/* This will stop the object from ever decaying */set_decay_speed(0);",}),]),}),"set_piece_description":({({"void",}),({({"string",}),"word",}),(["main":({"This sets the long description of the food when it is has'cut' into pieces.<p>If this is set then the short of the object is changedto 'piece of cake'.  If the piece description is notset the short description of the object is not changed.",}),"see":({"query_in_pieces()","set_piece_short()","set_piece_plural()","set_piece_substance()",}),"param":({"word The long description to use when cut into pieces.",}),"example":({"set_piece_description(\"The brown, soft, moist cake looks \"  \"totally wonderful.\\n\");",}),]),}),"unset_applicable":({({"void",}),({}),(["main":({"This sets it so the food cannot be applied.",}),"see":({"set_applicable()",}),]),}),"set_weight_per_bite":({({"void",}),({({"int",}),"number",}),(["main":({"This sets weight of each bite of the food object.  This isused along with the total weight of the object to calculatehow many bites of the food can be taken.",}),"param":({"number the weight each bite should be",}),"see":({"/std/basic/misc->set_weight()","weight",}),]),}),"set_eat_mess":({({"void",}),({({"string",}),"word",}),(["main":({"This sets the eat function of the food.  The function iscarried out when the food is consumed.  The eat message,set with set_eat_mess(), is displayed when this functionis carried out.<p>The eat mess should be treated exactly the same as aadd_succeeded_mess(), as it is processed later asadd_succeeded_mess(eat_mess, ({ }));",}),"param":({"word The string or array to be used asthe add_succeeded_mess() when eating the food.",}),"see":({"set_eat_object()","set_eat_func()","/global/new_parse->add_succeeded_mess()",}),]),}),"set_piece_plural":({({"void",}),({({"string",}),"plural",}),(["main":({"This plural description used for the pieces.  It is onlyreally of use if the piece short pluralises in an unusualmanner.  If it is not set the piece plural is set to whatthe pice short has been set to with an \"s\" stuck on theend, for example, slice to slices.",}),"see":({"query_in_pieces()","set_piece_description()","set_piece_short()","set_piece_substance()",}),"param":({"word The plural used for the 'pieces' when cut intopieces.",}),"example":({"set_piece_plural(\"slices\");",}),]),}),"unset_external_pk_check":({({"void",}),({}),(["main":({"This makes the external effects not pk checked.",}),"see":({"add_external_effect(), set_applicable(), set_splashable()","set_external_pk_check()",}),]),}),"setup_eat":({({"void",}),({({"string",}),"ob",({"string",}),"func",}),(["main":({"This sets up the eat object and function.  This is used whenthe food is eaten.  The eat function is called on the eatobject.  If successful the eat message is added to the player.",}),"param":({"ob the object to use","func the function to use",}),"see":({"set_eat_object()","set_eat_func()",}),]),}),"remove_external_effect":({({"void",}),({({"string",}),"word",}),(["main":({"This removes the external effect of the given name.",}),"see":({"add_external_effect()",}),"param":({"word the name of the effect to delete",}),]),}),"set_eat_func":({({"void",}),({({"string",}),"word",}),(["main":({"This sets the eat function of the food.  This is called whenthe food is eaten.<p>If the eat object is set, then the eat function needs to beset as well. If the function is not set then setting theobject has no effect.<p>The function will be called with two parameters, the first being theobject being eaten and the second being the person eating the object.",}),"param":({"word The function to set as the eat function.",}),"see":({"set_eat_object()","set_eat_mess()",}),"example":({"See the example for set_eat_object()",}),]),}),"add_external_effect":({({"int",}),({({"string",}),"word",({"int",}),"number",}),(["main":({"This adds an external effect to the food.  This will be added tothe player or NPC when the liquid is splashed, applied, or rubbed on them.<p>The effect is added with a number as the argument.  The numberis based on the amount which is splashed (in weight units), andusually represents the strength of the effect.If the object is continuous, the weight is calculated fromthe amount and weight_unit array...<p><br><code>eff_num = (amount * number * weight_unit[0]) / weight_unit[1]</code><p>...where the number is passed into the add_external_effect() function.If the effect already exists, then the number is added ontothe existing number.",}),"param":({"word The file name of the effect to add.","number The number to set to the effect to.",}),"see":({"/obj/cont_medium->set_weight_unit()","set_splashable()","unset_splashable()","set_applicable()","unset_applicable","remove_external_effect()","set_external_pk_check()",}),"return":({"The current value of the effect in the mapping",}),]),}),"do_drink":({({"int",}),({}),(["main":({"This gives the appropriate message for drinking things.",}),"see":({"do_eat()","consume(*)","set_liquid()",}),"return":({"Return 1 if it succeeded, or return 0 if it failed.",}),]),}),"reset_liquid":({({"void",}),({}),(["main":({"This changes the food object into a solid.  Solids are not'continuous' and the decay speed will be set back to thedefault.",}),"see":({"set_liquid()","set_decay_speed()",}),]),}),"add_eat_effect":({({"int",}),({({"mixed",}),"word",({"int",}),"number",}),(["main":({"This adds an eat effect to the food.  This will be added tothe player or NPC when the food is eaten.<p>The effect is added with a number as the argument.  The numberis based on the amount which is eaten (in weight units), andusually represents the strength of the effect.If the object is continuous, the weight is calculated fromthe amount and weight_unit array...<p><br><code>eff_num = (amount * number * weight_unit[0]) / weight_unit[1]</code><p>...where the number is passed into the add_eat_effect() function.If the effect already exists, then the number is added ontothe existing number.",}),"param":({"word the file name of the effect to add.","number the number to set to the effect to.",}),"see":({"/obj/cont_medium->set_weight_unit()","remove_eat_effect()",}),"return":({"the current value of the effect in the mapping",}),]),}),"query_in_pieces":({({"int",}),({}),(["main":({"If the food has been cut up (using the 'cut' command)then this will return true.",}),"see":({"do_cut()",}),"return":({"1 if it is in pieces, 0 if otherwise",}),]),}),"remove_eat_effect":({({"void",}),({({"string",}),"word",}),(["main":({"This removes the eat effect of the given name.",}),"see":({"add_eat_effect()",}),"param":({"word the name of the effect to delete",}),]),}),"query_eat_effects":({({"mapping",}),({}),(["main":({"The eat effects of the food.  The mapping contains a set ofstrings (the effect) and a number associated with theeffect.",}),"see":({"add_eat_effect()",}),"return":({"a mapping containing the eat effects",}),]),}),"query_liquid":({({"int",}),({}),(["main":({"This function returns true if the food is a liquid.",}),"return":({"1 if the food is a liquid, and 0 if it is not",}),]),}),"query_bites_gone":({({"int",}),({}),(["main":({"This returns the number of bites that have been taken outof the food object.",}),"see":({"set_bites_gone()","set_weight_per_bite()",}),"return":({"the number of bites which have been taken fromthe object",}),]),}),"set_bites_gone":({({"void",}),({({"int",}),"number",}),(["main":({"This sets the number of bites gone.This helps determine the total weight of the object.",}),"param":({"number the number of bites gone",}),"see":({"set_weight_per_bite()",}),]),}),"set_piece_short":({({"void",}),({({"string",}),"short",}),(["main":({"This is the description used in the short for the pieces.When the object is cut up this is used as part of theshort description.  For example, it can change'piece of cake' to 'slice of cake', 'piece of chocolate'to 'square of chocolate', and so on.  If this the pieceshort has not been set it is set to the default which issimply \"piece\".",}),"see":({"query_in_pieces()","set_piece_description()","set_piece_plural()","set_piece_substance()",}),"param":({"word The short to use for the 'piece' when cut intopieces.",}),"example":({"set_piece_short(\"slice\");",}),]),}),"check_sharp":({({"int",}),({({"object",}),"weapon",}),(["main":({"This checks to see if a weapon is sharp.  This is used laterto determine whather an object can be cut up with the weapon.",}),"param":({"weapon the weapon to check to see if it is sharp",}),"return":({"1 if it is sharp, or 0 if not",}),]),}),"query_external_effects":({({"mapping",}),({}),(["main":({"The external (splash,apply,rub) effects of the food.  Themapping contains a set of strings (the effect) and a numberassociated with the effect.",}),"see":({"set_splashable(), set_applicable()",}),"return":({"A mapping containing the external effects.",}),]),}),"query_food_type":({({"string",}),({}),(["main":({"This method returns the food type.",}),"see":({"set_food_type()",}),"return":({"the food type",}),]),}),"set_eat_effects":({({"void",}),({({"mapping",}),"map",}),(["main":({"This sets all the eat effects.  This function should NOTbe used.  Please use add_eat_effect.",}),"param":({"map the eat effects mapping",}),]),}),"query_weight_per_bite":({({"int",}),({}),(["main":({"This sets the weight of each bite of the food object.This is used along with the total weight of the objectto calculate how many bites of the food can be taken.",}),"see":({"/std/basic/misc->set_weight()","set_weight_per_bite()","weight",}),"return":({"the weight of each bite",}),]),}),"query_decay_level":({({"int",}),({}),(["main":({"This returns the level of the decay.  This will be a numberbetween 1 and 6.",}),"see":({"set_decay_speed()",}),"return":({"the level of decay, which is between 1 and 6",}),]),}),"set_piece_substance":({({"void",}),({({"string",}),"substance",}),(["main":({"This sets a new description for what there are pieces of.For example, if you want the short of the food before itis cut up to be 'bar of chocolate', without the piecesubstance being set, when it is cut up it will become'a piece of bar of chocolate'.  If you set this in enablesyou to change that unwieldly description to 'a piece ofchocolate'.",}),"see":({"query_in_pieces()","set_piece_description()","set_piece_short()","set_piece_plural()",}),"param":({"word The description of what the 'piece' is of.",}),"example":({"set_piece_substance(\"goat cheese\");",}),]),}),"do_cure":({({"int",}),({}),(["main":({"This is called by the pickling stick.  It stops the foodobject decaying.",}),"see":({"set_decay_speed()",}),"return":({"always returns 1",}),]),}),"query_food_object":({({"int",}),({}),(["main":({"This method returns 1 if the item is a food object.",}),"return":({"1 when it is a food object",}),]),}),"do_apply":({({"int",}),({({"object","*",}),"things",}),(["main":({"This handles applying things.",}),"see":({"set_applicable()","consume(*)",}),"return":({"Return 1 if it succeeded, or return 0 if it failed.",}),]),}),"do_eat":({({"varargs","int",}),({({"int",}),"no_mess",}),(["main":({"This is the eat command call.  This is setup with add_command()and does the actual eating.",}),"see":({"/global/new_parse->add_command()","/global/new_parse->add_succeeded_mess()","set_eat_mess()",}),"param":({"no_mess don't use success messages",}),"return":({"Return 1 on success, 2 on success + last bit eaten and return 0 on failure.",}),]),}),"query_splashable":({({"int",}),({({"object",}),"splasher",({"object",}),"splashee",}),(["main":({"This queries splashability of the food.Note that the food can only be splashed when liquid and whenset_splashable() has been called",}),"see":({"set_splashable(), unset_splashable(), set_liquid(),set_external_pk_check()",}),"param":({"splasher - Who splashes.","splashee - Who is splashed.",}),"return":({"1 if it can splash, 0 if it can't",}),]),}),"set_decay_level":({({"void",}),({({"int",}),"level",}),(["main":({"This sets the decay level.  This should be anumberbetween 1 and 6.  It lets you make a food object seemas though it is already decaying.",}),"param":({"level The new decay level.",}),"see":({"query_decay_level()","set_decay_speed()",}),]),}),"query_decay":({({"int",}),({}),(["main":({"This method returns which niche the food object has decayed to.Should never be more than 6.",}),]),}),"check_for_container":({({"int",}),({}),(["main":({"This checks the outside of us for a container and then destroys ourselvesif it is not a container.",}),]),}),"set_splashable":({({"void",}),({}),(["main":({"This sets it so the food can be splashed.Note that the food can only be splashed when liquid in any case.Note this is NOT the default case.",}),"see":({"unset_splashable(), set_applicable(), unset_applicable(),add_external_effect()",}),]),}),"set_in_pieces":({({"void",}),({({"int",}),"number",}),(["main":({"This sets the in_pieces flag.  This allows you to make thefood seem as though it has already been cut into pieces.",}),"see":({"query_in_pieces()","set_piece_description()","set_piece_short()","set_piece_plural()","set_piece_substance()",}),"param":({"number the number of pieces",}),]),}),"query_piece_description":({({"string",}),({}),(["main":({"This returns the long description of the food object whenit is cut up into pieces.",}),"see":({"set_piece_description()","query_in_pieces()",}),"return":({"the piece description",}),]),}),"query_decays":({({"int",}),({}),(["main":({"This query tells us whether the food decays.  All objectswhich decay should have this function on them.",}),"see":({"set_decay_speed()",}),"return":({"1 if the object decays",}),]),}),"set_external_effects":({({"void",}),({({"mapping",}),"map",}),(["main":({"This sets all the external effects.  This function should NOTbe used.  Please use add_external_effect.",}),"param":({"map the external effects mapping",}),]),}),"set_external_pk_check":({({"void",}),({}),(["main":({"This makes the external effects pk checked.",}),"see":({"add_external_effect(), set_applicable(), set_splashable()","unset_external_pk_check()",}),]),}),"query_edible":({({"int",}),({}),(["main":({"This tells us if the food is edible (ie. can beconsumed using 'eat' instead of 'drink'.  If it isedible then it is not a liquid.",}),"see":({"set_liquid()","query_liquid()",}),"return":({"1 if the food is a liquid, and 0 if it is not",}),]),}),"query_eat_object":({({"string",}),({}),(["main":({"This returns the eat object on which the eat functionof the food is stored.",}),"see":({"set_eat_object()","set_eat_func()","set_eat_mess()",}),"return":({"the name of the eat object",}),]),}),"set_eat_object":({({"void",}),({({"string",}),"word",}),(["main":({"This sets the object on which the eat function is stored.<p>If the eat object is set, then the eat function needs tobe set as well.  If the function is not set then settingthe object has no effect.<p>The function will be called with two parameters, the firstbeing the object being eaten and the second being theperson eating the object.",}),"param":({"word The object containing the eat function.",}),"see":({"set_eat_object()","set_eat_mess()",}),"example":({"void create_food() {  object food;  food = clone_object(\"/obj/food/apple.food\");  food->set_eat_object(TO);  food->set_eat_func(\"eat_apple\");} /* create_food() */void eat_apple(object food, object eater) {  /* Do something wonderful! */} /* eat_rabbit() */",}),]),}),"query_applicable":({({"int",}),({({"object",}),"applier",({"object",}),"appliee",}),(["main":({"This queries applicability of the food. (rubbing on someone)Note that the food can only be applied whenset_applicable() has been called",}),"see":({"set_applicable(), unset_applicable(), set_external_pk_check()",}),"param":({"applier - Who applies it","appliee - Who it is applied to.",}),"return":({"1 if it can be applied, 0 if it can't",}),]),}),"set_applicable":({({"void",}),({}),(["main":({"This sets it so the food can be applied.Note this is the default case.",}),"see":({"unset_applicable()",}),]),}),"set_food_type":({({"void",}),({({"string",}),"type",}),(["main":({"This sets which type the food is, for the disease handler.",}),"see":({"query_food_type()",}),"param":({"type the food type to set",}),]),}),])
protected_functions ([])
inherits (["/obj/cont_medium":({}),])
main_docs (["main":({"<BR>This is the main inheritable for food objects.  It allows you tocreate food and drink.  Virtual files may also be coded if giventhe *.food extention.  There are many examples of these virtualfood files in the /obj/food directory.  Food does the followingthings.<BR><BR>  - It can be eaten or drunk.<BR>  - Food can be changed from solid to liquid with set_liquid(),and changed from liquid to solid with reset_liquid().<BR>  - The weight of each bite can be set with set_weight_per_bite().<BR>  - Effects can be added to the player when they are splashed with the food,get food rubbed on them, or get food applied to them withadd_external_effect.<BR>  - Splashing, applying, and rubbing can be pk-checked withset_external_pk_check()<BR>  - Splashing can be activated with set_splashable()<BR>  - Splashing can be deactivated with unset_splashable()<BR>  - Applying can be activated with set_applicable()<BR>  - Applying can be deactivated with unset_applicable()<BR>  - Effects can be added to the player when they consume the foodwith add_eat_effect().<BR>  - Functions can be added to be carried out when the food isconsumed with add_eat_func().  This function can be storedon another object if the set_eat_object() is used.<BR>  - An eat message can be set with set_eat_mess().<BR>  - Food can be cut up into pieces with sharp weapons.<BR>  - The description of the new 'pieces' can be set usingset_piece_description(), set_piece_short(), set_piece_plural(),and set_piece_substance().<BR>  - Non-liquid food decays and will eventually crumble to dust.<BR>  - The decay speed can be set with set_decay_speed().<BR>  - Food can be 'pickled' to prevent decay using do_cure().",}),])
define_docs (["STATE_CHANGE":([]),"DEFAULT_DECAY":([]),])
includes (["/include/weapon.h":962428284,"/include/move_failures.h":962428284,"/include/bits_controller.h":962428284,"/include/diseases.h":983677817,"/include/drinks.h":962428284,])
class_docs ([])
file_name "/obj/food.c"
last_changed 1079290660
