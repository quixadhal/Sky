#/secure/handlers/autodoc/autodoc_file.c
public_functions (["enable_item_tracking":({({"nomask","void",}),({}),(["main":({"This method enables item tracking",}),"see":({"event_enter_tracked_item","disable_item_tracking",}),]),}),"event_container_move":({({"nomask","void",}),({({"object",}),"mover",({"mixed",}),"from",({"mixed",}),"to",}),(["main":({"This method handles the movement of the containers of this object.Tracked items want to be notified if the container moves or anythingcontaining it does.  The movement of the outmost moving container ispropagated down to all tracked items.",}),"see":({"event_enter_tracked_item",}),"param":({"mover the outermost container object that moved","from the start environment of the outermost container","to the destination of the outermost container",}),]),}),"reset_prevent_insert":({({"int",}),({}),(["main":({"This allows this container to be added into other containers (default).",}),"see":({"set_prevent_insert()","query_prevent_insert()",}),]),}),"query_tracked_items":({({"nomask","int",}),({}),(["main":({"This method returns the number of tracked item contained.Tracked items want to be notified if the container moves.",}),"see":({"add_tracked_items","event_container_move",}),]),}),"remove_tracked_items":({({"nomask","void",}),({({"int",}),"n_items",}),(["main":({"This method handles the removal of tracked items.Tracked items want to be notified if the container moves.",}),"see":({"add_tracked_items","event_container_move",}),"param":({"n_items the number of tracked items  removed",}),]),}),"query_ownership":({({"string",}),({}),(["main":({"This returns who owns the container, if it set to 0 then no oneowns it.  This is used in the theft determination for the object.",}),"see":({"set_ownership()",}),"return":({"who owns the container",}),]),}),"add_weight":({({"int",}),({({"int",}),"n",}),(["main":({"This method is called in the move functions, it adds extraweight onto the object when something is moved inside it.",}),"see":({"/std/basic/misc->query_weight()",}),"param":({"n the amount to add",}),"return":({"1 if successfuly added",}),]),}),"update_loc_weight":({({"void",}),({}),(["main":({"This method determines the current local weight from all theobjects inside the conatiner",}),"see":({"query_loc_weight()",}),]),}),"query_prevent_insert":({({"int",}),({}),(["main":({"If this is true, this container cannot be added into othercontainers.",}),"see":({"reset_prevent_insert()","set_prevent_insert()",}),]),}),"set_prevent_insert":({({"int",}),({}),(["main":({"This prevents this container from being added into other containers.",}),"see":({"reset_prevent_insert()","query_prevent_insert()",}),]),}),"disable_item_tracking":({({"nomask","void",}),({}),(["main":({"This method disables item tracking",}),"see":({"event_enter_tracked_item","enable_item_tracking",}),]),}),"can_find_match_recurse_into":({({"int",}),({({"object",}),"looker",}),(["main":({"This method allows the container to have stuff inside it checked.",}),"param":({"looker the person doing the checking",}),"return":({"1 on success, 0 on failur",}),]),}),"add_tracked_items":({({"nomask","void",}),({({"int",}),"n_items",}),(["main":({"This method handles the addition of tracked items.Tracked items want to be notified if the container moves.",}),"see":({"remove_tracked_items","event_container_move",}),"param":({"n_items the number of tracked items added",}),]),}),"can_find_match_reference_inside_object":({({"int",}),({({"object",}),"thing",({"object",}),"looker",}),(["main":({"This method checks to see if the find match code can actuallyreference this object inside us.",}),"param":({"thing the thing to reference","looker the person looking at it",}),"return":({"1 if they can, 0 if they cannot",}),]),}),"set_tracked_item_status_reason":({({"nomask","void",}),({({"string",}),"reason",}),(["main":({"This method is called to adjust the status reason.occurences.",}),"see":({"event_buried","event_player_quit","event_enter_tracked_item",}),]),}),"test_remove":({({"int",}),({({"object",}),"thing",({"int",}),"flag",({"mixed",}),"dest",}),(["main":({"This method checks to see if the object can be taken out ofus.",}),"see":({"/std/basic/move.c",}),"param":({"thing the object coming out","flag the move flag","dest the destination object",}),"return":({"1 if it can be taken out, 0 if not.",}),]),}),"event_move_object":({({"void",}),({({"mixed",}),"from",({"mixed",}),"to",}),(["main":({"This method is called from move to notify any tracked items contained ofthe move using event_container_moved.",}),"param":({"from start","to destination",}),]),}),"query_max_weight":({({"int",}),({}),(["main":({"This method returns the maximum amount of weight that canbe carried in this container.",}),"see":({"set_max_weight()",}),"return":({"the maximum weight",}),]),}),"test_add":({({"int",}),({({"object",}),"ob",({"int",}),"flag",}),(["main":({"This method allows things to be added into us.  If we have anenvironment check that for the ability to add into us.",}),"see":({"/std/basic/move.c","add_weight()",}),"param":({"ob the object being added","flag the add flags",}),]),}),"set_max_weight":({({"void",}),({({"int",}),"number",}),(["main":({"This method sets the maximum amount of weight that canbe carried in this container.",}),"see":({"query_max_weight()",}),"param":({"number the new maximum weight",}),]),}),"set_ownership":({({"void",}),({({"string",}),"word",}),(["main":({"This sets who owns the container, if it set to 0 then no oneowns it.  This is used in the theft determination for the object.",}),"see":({"query_ownership()",}),"param":({"word who owns the container",}),]),}),"query_loc_weight":({({"int",}),({}),(["main":({"This method returns the current local weight in thiscontainer.",}),"return":({"the local weight",}),]),}),"find_inv_match":({({"object","*",}),({({"string",}),"words",({"object",}),"looker",}),(["main":({"This method finds the matching objects inside this objectthat are visible to the looker.  This will also use theregistered containers and add them into the array returned(if visible and contained in the object).",}),"param":({"words the words matched on","looker who is looking",}),"see":({"/secure/simul_efun->find_match()","add_inventory_container()",}),]),}),"query_complete_weight":({({"int",}),({}),(["main":({"This method returns the complete weight of the object.  This is theweight of the container itself, plus the weight of the thingsinside it",}),"see":({"/std/basic/misc->query_weight()","query_loc_weight()",}),"return":({"the complete_weight()",}),]),}),])
protected_functions (["handle_restore_inventory":({({"int",}),({({"object",}),"ob",}),(["main":({"This method handles moving objects into the inventory from an autoload.  This should be over ridden by things inheriting us tomake sure that the objects can be moved into the inventory.  Itshould handle the bypassing of open/close/locked etc flags.",}),"param":({"ob the object to move into ourselves",}),]),}),])
inherits (["/std/basic/cute_look":({}),"/std/object":({}),"/std/basic/export_inventory":({}),])
main_docs (["main":({"The basic container inheritable, please note this is *not* a containerlike a bucket.  This now allows things inside the container toinform us that they should be used as part of the inventory of thisobject.  This means the contents of containers will look like theyare not inside containers to the outside world.",}),"author":({"Pinkfish",}),"see":({"/obj/container.c","/obj/baggage.c","/obj/vessel.c","/obj/clothing.c",}),])
define_docs ([])
includes (["/include/player.h":1036911799,"/include/move_failures.h":962428284,"/include/playtesters.h":1020949410,])
class_docs ([])
file_name "/std/container.c"
last_changed 1057832900
