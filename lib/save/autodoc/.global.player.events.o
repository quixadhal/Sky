#/secure/handlers/autodoc/autodoc_file.c
public_functions (["set_rows":({({"void",}),({({"int",}),"i",}),(["main":({"This method sets the number of rows on the players screen.",}),"see":({"query_rows()",}),"param":({"i the new number of rows",}),]),}),"event_chat":({({"void",}),({({"object",}),"ob",({"string",}),"caller",({"string",}),"verb",({"string",}),"text",({"int",}),"emote",({"int",}),"force",}),(["main":({"This event is generated when a creator tell is done.",}),"param":({"ob the object generating the event","start the start bit","mess the message bit","forced if it is forced to occur",}),]),}),"window_size":({({"void",}),({({"int",}),"width",({"int",}),"height",}),(["main":({"This is a call back generated by the driver internally to tell us aboutthe window size of the remote machine.  This information in this isonly used if the terminal is a network type.",}),"param":({"width the number of columns","height the number of rows",}),]),}),"set_cols":({({"void",}),({({"int",}),"i",}),(["main":({"This method sets the current number of columns the player has set ontheir screen.",}),"see":({"query_cols()",}),"param":({"i the new number of columns",}),]),}),"fit_message":({({"string",}),({({"string",}),"message",}),(["main":({"This method fits a message into a the current players screen size.  Thisdoes all sorts of other evil stuff too, like handling indenting andall sorts of things!  Most of which I do not understand so I won'tsay anything about here.",}),"param":({"message the message to fit in",}),"return":({"the fitted message",}),]),}),"event_emote":({({"void",}),({({"object",}),"thing",({"string",}),"mess",}),(["main":({"This method is called when someone does an emote.",}),"param":({"thing the object doing the emote","mess the emote to print",}),]),}),"event_newbie":({({"void",}),({({"object",}),"thing",({"string",}),"message",}),(["main":({"This event is generated when a newbie chat event is done.",}),"param":({"thing the thing generateing the newbie chat","message the message the newbie said",}),]),}),"query_rows":({({"int",}),({}),(["main":({"This method returns the current number of rows the player hasset on their screen.",}),"see":({"set_rows()",}),"return":({"the number of rows on the screen",}),]),}),"event_inform":({({"varargs","void",}),({({}),"object",({"mixed",}),"mess",({"string",}),"which",({"object",}),"thing",}),(["main":({"This method is called when an inform event is called.",}),"param":({"mess the message to print","which the type of inform",}),"parm":({"thing the thing associated with the inform",}),]),}),"event_commands":({({"void",}),({}),(["main":({"This method adds all the event commands onto the player.This will be called in the player startup sequence.",}),]),}),"event_enter":({({"void",}),({({"object",}),"thing",({"string",}),"mess",({}),"object",}),(["main":({"This method is called when an object enters the room.",}),"param":({"thing the thing entering","mess the message to print on entering",}),]),}),"event_inter_creator_tell":({({"void",}),({({"object",}),"ob",({"string",}),"mname",({"string",}),"pname",({"string",}),"mess",({"object",}),"ig",({"int",}),"emote",}),(["main":({"This event is generated when a intermud creator tell is done.",}),"param":({"ob the object generating the event","mname the name of the mud","pname the name of the player","mess the message","ig the ignore object","emote if it is an emote",}),]),}),"query_see_octarine":({({"int",}),({}),(["main":({"This method tests to see if the player can see octarine objects.",}),"return":({"1 if they can see octarine, 0 if they cannot",}),]),}),"do_busy":({({"int",}),({({"string",}),"str",}),(["main":({"This method handles setting the busy flag.  The busy flag can onlybe set by liaisons and lords, why lords?  Just because :)  Thiscommand was inspired by moonchild.",}),"param":({"str the on or off string",}),"return":({"1 on success, 0 on failure",}),]),}),"add_message":({({"void",}),({({"string",}),"message",({"mixed",}),"things",}),(["main":({"This adds a message into the current list of printable messages.  Thiswill be squided up together and printed out slightly later, this handlesthe concatenating of enter messages, and soul messages.  Etc.",}),"see":({"reform_message()",}),"param":({"message the message to add","things the objects which are involved with the message",}),]),}),"event_player_emote_all":({({"void",}),({({"object",}),"ob",({"string",}),"mess",}),(["main":({"This method is called when an emoteall is generated by a player.",}),"param":({"ob the object doing the emoteall","mess the message being printed",}),]),}),"event_exit":({({"void",}),({({"object",}),"thing",({"string",}),"mess",({"object",}),"to",}),(["main":({"This method is printed when an object exits the room.",}),"param":({"thing the object exiting","mess the message to print","to where the object is going to",}),]),}),"convert_message":({({"string",}),({({"string",}),"message",}),(["main":({"This method will handle doing exciting things to messages andreturning them as a usable format.",}),"see":({"evaluate_message()",}),"param":({"message the message to evaluate",}),"return":({"the message in a printable (to the player) format",}),]),}),"query_busy":({({"mixed",}),({}),(["main":({"This method tells us if the player/creator/lord is currently in busymode.  This will be 1 if the creatopr is generaly busy, orit will return the array of players they are busy with.",}),"return":({"the busy mode flag",}),]),}),"print_messages":({({"void",}),({}),(["main":({"This prints out the messages after the delay, printing out themessages in a nice cute way.  It still retains the order of themessages though.  This can be forced to occur by a messageoccuring on the player object which requires something tobe printed.",}),"see":({"evaluate_message()","show_message()",}),]),}),"evaluate_message":({({"string",}),({({"mixed",}),"stuff",}),(["main":({"This is the main evaluation routine.  This is the one thatco-ordinates the works...  It is used by the print_messagesroutine to create the message to print out.<p>The input parameter contains two elements, the first is themessage and the second is the things array.  This corresponds tothe values returned by the fix_message method.",}),"see":({"print_messages()",}),"param":({"stuff the message to evaulate",}),"return":({"the nice printed out string",}),]),}),"query_cols":({({"int",}),({}),(["main":({"This method returns the current number of columns the player hasset on their screen.",}),"see":({"set_cols()",}),"return":({"the number of columns on the screen",}),]),}),"terminal_type":({({"void",}),({({"string",}),"type",}),(["main":({"This is a call back generated by the driver internally to tell us aboutterminal types.",}),"param":({"type the terminal type returned",}),]),}),"event_intermud_tell":({({"void",}),({({"object",}),"ob",({"string",}),"start",({"string",}),"mess",({"string",}),"channel",({"object",}),"ig",({"int",}),"emote",}),(["main":({"This event is generated when a creator tell is done.",}),"param":({"ob the object generating the event","mname the name of the mud","pname the name of the player","mess the message","ig the ignore object","emote if it is an emote",}),]),}),"set_term_type":({({"int",}),({({"string",}),"str",}),(["main":({"This method sets the current terminal type for the player.  If the typeis network, then the network will be queried for the terminal typeand that will be used.  This is the distiction between the currentterminal type and the terminal name.  The name will be the value thatis set by the player and the current type will be the informationgarnered from the network (if the name is network) or the same as thename.",}),"see":({"set_term()","query_term_name()","query_cur_term()",}),"param":({"str the new terminal type",}),"return":({"1 if the terminal was successful set, 0 if not",}),]),}),"event_player_echo_to":({({"void",}),({({"object",}),"ob",({"string",}),"mess",({"object",}),"me",}),(["main":({"This method is called when an echo to is generated by the player.",}),"param":({"ob the object doing the echo to","mess the message being printed","me the person generating the echo to",}),]),}),"query_earmuffs":({({"int",}),({}),(["main":({"This method tells us if the player currently has earmuffs turned on.",}),"see":({"check_earmuffs()","toggle_earmuffs()",}),"return":({"1 if earmuffs are on, 0 if they are not",}),]),}),"colour_event":({({"string",}),({({"string",}),"event_type",({"string",}),"default_colour",}),(["main":({"This function returns the appropriate colour codes for the given eventtype. It will return the players chosen colour if they've set one orthe default if not.",}),"param":({"event_type The type of event",}),"return":({"a string of colour codes.",}),]),}),"event_write":({({"void",}),({({"object",}),"caller",({"string",}),"str",}),(["main":({"This method is called by the simul_efun 'write'.",}),"param":({"caller the calling object","str the string to write",}),]),}),"get_hsay_func":({({"function",}),({}),(["main":({"Return function pointer for do_say_his, for history say only.",}),]),}),"toggle_earmuffs":({({"void",}),({}),(["main":({"This method will change the current value of the earmuffs on the player.",}),"see":({"check_earmuffs()","query_earmuffs()",}),]),}),"set_looked":({({"void",}),({({"object",}),"thing",}),([]),}),"event_person_say":({({"void",}),({({"object",}),"ob",({"string",}),"start",({"string",}),"mess",({"string",}),"lang",}),(["main":({"This method is called when someone says something.",}),"param":({"ob the object doing the say","start the start message","mess the message to say","lang the language it is printed in",}),]),}),"my_mirror_short":({({"string",}),({({"object",}),"thing",({"string",}),"arg",}),(["main":({"This is a special function for use with the reform message, it allowsthe string to be echoed into the list instead of using the object'svalue itself.  This is done specifically to handle objects withvariable shorts, so we get the short description correct at themoment it is queried.",}),]),}),"reform_message":({({"mixed",}),({({"string",}),"message",({"mixed",}),"things",}),(["main":({"This method does all those terrible things with messages and $'sturning them into real strings.  It is a neat function if somewhatcomplicated :)  It was written by Deutha.<p>The return array has two elements, the first being the reformedmessage and the second being the reformed things array.",}),"param":({"message the message to reform","things some bonus things to reform it with",}),"return":({"an array consisting of two elements",}),]),}),"do_busy_player":({({"int",}),({({"object","*",}),"obs",}),(["main":({"This method allows creators to set the player for whom they are currentlybusy too.",}),"param":({"obs the player to be busy with",}),"return":({"1 on success, 0 on failure",}),]),}),"event_soul":({({"varargs","void",}),({({"object",}),"ob",({"string",}),"str",({"mixed",}),"avoid",}),(["main":({"This method is called by the soul to print out the soul messages.",}),"param":({"ob the object doing the soul","str the string to print","avoid the people not to print the message to",}),]),}),"receive_snoop":({({"void",}),({({"string",}),"mess",}),(["main":({"This method is generated internally by the driver when this player issnooping someone else.",}),"param":({"mess the snoop message",}),]),}),"event_creator_tell":({({"void",}),({({"object",}),"ob",({"string",}),"start",({"string",}),"mess",({"int",}),"forced",}),(["main":({"This event is generated when a creator tell is done.",}),"param":({"ob the object generating the event","start the start bit","mess the message bit","forced if it is forced to occur",}),]),}),"fix_string":({({"varargs","string",}),({({"string",}),"str",({"int",}),"width",({"int",}),"indent",({"mixed","args",}),"...",}),(["main":({"This method handles the conversersions for the colour mapping which isdone on Discworld.  This also does octarine message expansion, if thekeyword %\\^OCTARINE:message%\\^ is embeded into a string then theinside section will be replaced with a blank string if the playercannot see octarine messages.",}),"see":({"efun::terminal_colour()",}),"param":({"str the string to do the conversion on","width the width of the string","indent the size of the indent","args any other arguments",}),"return":({"the fixed up string",}),]),}),"event_whisper":({({"void",}),({({"object",}),"ob",({"string",}),"start",({"string",}),"mess",({"object","*",}),"obs",({"string",}),"lang",({"object",}),"me",}),(["main":({"This method is called when the whisper even is generated.",}),"param":({"ob the object whispering","start the start of the whisper message","mess the message to print","obs the objects to tell the message to","lang the lanaguage the whisper is in","me the object doing the whispering",}),]),}),"query_cur_term":({({"string",}),({}),(["main":({"This method returns the current terminal type that is being used.  Thiswill be 0 if the terminal name is set to network and no response hasbeen gained from the remote site yet.  Otherwise it should be thesame value as the terminal name.",}),"see":({"query_term_name()","set_term_type()",}),"return":({"the current terminal type",}),]),}),"show_message":({({"void",}),({({"string",}),"message",}),(["main":({"This method shows the message to the player.",}),"see":({"fit_message()",}),"param":({"message the message to show",}),]),}),"query_my_colours":({({"mapping",}),({}),(["main":({"Return a players list of custom colours.",}),"return":({"a mapping of the players custom colours for different events.",}),]),}),"set_my_colours":({({"void",}),({({"string",}),"event_type",({"string",}),"colour",}),(["main":({"This method sets the colour codes for a given event.",}),"param":({"event_type the type of event to set the colour for","colour the colour to set",}),]),}),"get_htell_func":({({"function",}),({}),(["main":({"Return function pointer for do_tell_his, for history tell only.",}),]),}),"query_term_name":({({"string",}),({}),(["main":({"This method returns the current terminal name.  If this is set tonetwork then the network will be queried for the terminal type(using telnet suboption negotiation).",}),"see":({"query_cur_term()","set_term_type()",}),"return":({"the current terminal name",}),]),}),"event_player_echo":({({"void",}),({({"object",}),"ob",({"string",}),"mess",}),(["main":({"This method is called when an echo is generated by a player.",}),"param":({"ob the object doing the echo","mess the message being printed",}),]),}),"query_inform_types":({({"string","*",}),({}),(["main":({"This method returns the list of inform types this player can receive.",}),"return":({"array of inform types",}),]),}),"event_person_shout":({({"void",}),({({"object",}),"thing",({"string",}),"start",({"string",}),"mess",({"string",}),"lang",({"int","*",}),"co_ord",({"int",}),"range",}),(["main":({"This method is generated when a shout is done by a player.",}),"param":({"thing the thing doing the shout","start the start string to print","mess the message to print","lang the language the shout is in","co_ord the co-ordinate of the shouter","range the range of the shout",}),]),}),"event_see":({({"void",}),({({"object",}),"caller",({"string",}),"words",({"object",}),"thing",({"mixed",}),"avoid",}),([]),}),"event_say":({({"void",}),({({"object",}),"caller",({"string",}),"str",({"mixed",}),"avoid",}),(["main":({"This method is called when the 'say' and 'tell_room' simul_efuns is used.",}),"param":({"caller the object doing the say","str the message to print","avoid the people to avoid in the say",}),]),}),"query_is_dark":({({"int",}),({({"object",}),"thing",}),(["main":({"This method checks whether or not the room theplayer is in is dark enough to use 'someone'instead of regular shorts.",}),]),}),"set_network_terminal_type":({({"int",}),({({"string",}),"name",}),(["main":({"This method handles the responses from the remote site informingus of their terminal type.",}),"see":({"set_term_type()","query_term_name()","query_cur_term()",}),"param":({"name the terminal type gathered from the remote site",}),"return":({"0 if the type was not used, 1 if it was",}),]),}),"octarine_message":({({"string",}),({({"string",}),"str",}),(["main":({"This method will do the octarine checking for you on the message.",}),"see":({"query_see_octarine()",}),"param":({"str the string to check",}),"example":({"string query_long_bit() {  return \"Glinting and sharp looking, the long sword is an impressive \"         \"weapon in the hands of someone knowledgeable.\\n\" +         this_player()->octarine_message(\"It glows with a fluffy octarine \"                                         \"aura.\\n\");} /* query_long_bit() */",}),]),}),"event_person_tell":({({"void",}),({({"object",}),"ob",({"string",}),"start",({"string",}),"mess",}),(["main":({"This method is called when a person is told something.",}),"param":({"ob the object doing the tell","start the start bit of the message","mess the message itself",}),]),}),"check_earmuffs":({({"int",}),({({"string",}),"type",}),(["main":({"This method checks to see if a particular event is earmuffed.",}),"see":({"toggle_earmuffs()","query_earmuffs()",}),"param":({"type the type of event to check",}),"example":({"  obs = users();  obs = filter( obs, (: $1->check_earmuffs(\"shout\") :) );  // Do the shout",}),"return":({"1 if the event is earmuffed and 0 if it is not",}),]),}),])
protected_functions (["enter_exit_mess":({({"void",}),({({"string",}),"mess",({"object",}),"thing",({"int",}),"going",}),(["main":({"This method is called when an object leaves or arrives inthe room.  It prints outthe message, well adds it to the queue of printable messages.",}),"param":({"mess the message to print","thing the thing which is leaving/arriving","going if it is going",}),]),}),"do_inform":({({"int",}),({({"string",}),"str",}),(["main":({"This is the command to handle the inform stuff.It does all the turning on/off and stuff things for the informs.",}),"see":({"event_inform()",}),"param":({"str the informs to listen to",}),]),}),"do_say_his":({({"varargs","int",}),({({"string",}),"str",({"int",}),"brief",}),(["main":({"This method is the command used to print a players say history.",}),]),}),"do_tell_his":({({"varargs","int",}),({({"string",}),"str",({"int",}),"brief",}),(["main":({"This method is the command used to print a players tell history.",}),]),}),])
inherits (["/global/player/new_parse":({}),"/global/player/play_parse_com":({}),"/global/player/communicate":({}),])
main_docs (["main":({"This file contains all the standard event handling code that playersneed.  This will handle things like informs, shouts, says, tells,whispers.  Everything!   It formats the message correctly andsends it to the player.",}),"author":({"Pinkfish",}),])
define_docs (["SPACES":([]),])
includes (["/include/player.h":1036911799,"/include/language.h":980398293,"/include/dirs.h":997617456,"/include/telnet.h":962428284,"/include/playtesters.h":1020949410,])
class_docs ([])
file_name "/global/player/events.c"
last_changed 1059815880
